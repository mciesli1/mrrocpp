// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef PIPEPNML_HXX
#define PIPEPNML_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3020000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< type, char, ncname > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY_IN___XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY_IN___XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class value_t;
class pnml_t;
class net_t;
class labels_t;
class place_t;
class initialMarking_t;
class capacity_t;
class trajectory_t;
class toolspecific_t;
class transition_t;
class orientation_t;
class rate_t;
class timed_t;
class infiniteServer_t;
class priority_t;
class arc_t;
class inscription_t;
class tagged_t;
class arcpath_t;
class type_t;
class graphics_t;
class offset_t;
class position_t;
class name_t;
class name1_t;
class task_t;

#include <memory>    // std::auto_ptr
#include <algorithm> // std::binary_search

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class value_t: public ::xml_schema::type
{
  public:
  // value
  // 
  typedef ::xml_schema::nmtoken value1_type;
  typedef ::xsd::cxx::tree::traits< value1_type, char > value1_traits;

  const value1_type&
  value1 () const;

  value1_type&
  value1 ();

  void
  value1 (const value1_type& x);

  void
  value1 (::std::auto_ptr< value1_type > p);

  // Constructors.
  //
  value_t (const value1_type&);

  value_t (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  value_t (const value_t& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual value_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~value_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< value1_type > value1_;
};

class pnml_t: public ::xml_schema::type
{
  public:
  // net
  // 
  typedef ::net_t net_type;
  typedef ::xsd::cxx::tree::traits< net_type, char > net_traits;

  const net_type&
  net () const;

  net_type&
  net ();

  void
  net (const net_type& x);

  void
  net (::std::auto_ptr< net_type > p);

  // Constructors.
  //
  pnml_t (const net_type&);

  pnml_t (::std::auto_ptr< net_type >&);

  pnml_t (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  pnml_t (const pnml_t& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual pnml_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~pnml_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< net_type > net_;
};

class net_t: public ::xml_schema::type
{
  public:
  // name
  // 
  typedef ::name1_t name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::auto_ptr< name_type > p);

  // labels
  // 
  typedef ::labels_t labels_type;
  typedef ::xsd::cxx::tree::sequence< labels_type > labels_sequence;
  typedef labels_sequence::iterator labels_iterator;
  typedef labels_sequence::const_iterator labels_const_iterator;
  typedef ::xsd::cxx::tree::traits< labels_type, char > labels_traits;

  const labels_sequence&
  labels () const;

  labels_sequence&
  labels ();

  void
  labels (const labels_sequence& s);

  // place
  // 
  typedef ::place_t place_type;
  typedef ::xsd::cxx::tree::sequence< place_type > place_sequence;
  typedef place_sequence::iterator place_iterator;
  typedef place_sequence::const_iterator place_const_iterator;
  typedef ::xsd::cxx::tree::traits< place_type, char > place_traits;

  const place_sequence&
  place () const;

  place_sequence&
  place ();

  void
  place (const place_sequence& s);

  // transition
  // 
  typedef ::transition_t transition_type;
  typedef ::xsd::cxx::tree::sequence< transition_type > transition_sequence;
  typedef transition_sequence::iterator transition_iterator;
  typedef transition_sequence::const_iterator transition_const_iterator;
  typedef ::xsd::cxx::tree::traits< transition_type, char > transition_traits;

  const transition_sequence&
  transition () const;

  transition_sequence&
  transition ();

  void
  transition (const transition_sequence& s);

  // arc
  // 
  typedef ::arc_t arc_type;
  typedef ::xsd::cxx::tree::sequence< arc_type > arc_sequence;
  typedef arc_sequence::iterator arc_iterator;
  typedef arc_sequence::const_iterator arc_const_iterator;
  typedef ::xsd::cxx::tree::traits< arc_type, char > arc_traits;

  const arc_sequence&
  arc () const;

  arc_sequence&
  arc ();

  void
  arc (const arc_sequence& s);

  // id
  // 
  typedef ::xml_schema::ncname id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // type
  // 
  typedef ::xml_schema::string type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // Constructors.
  //
  net_t (const id_type&,
         const type_type&);

  net_t (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  net_t (const net_t& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual net_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~net_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  name_optional name_;
  labels_sequence labels_;
  place_sequence place_;
  transition_sequence transition_;
  arc_sequence arc_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< type_type > type_;
};

class labels_t: public ::xml_schema::type
{
  public:
  // text
  // 
  typedef ::xml_schema::string text_type;
  typedef ::xsd::cxx::tree::traits< text_type, char > text_traits;

  const text_type&
  text () const;

  text_type&
  text ();

  void
  text (const text_type& x);

  void
  text (::std::auto_ptr< text_type > p);

  // border
  // 
  typedef ::xml_schema::boolean border_type;
  typedef ::xsd::cxx::tree::traits< border_type, char > border_traits;

  const border_type&
  border () const;

  border_type&
  border ();

  void
  border (const border_type& x);

  // height
  // 
  typedef ::xml_schema::integer height_type;
  typedef ::xsd::cxx::tree::traits< height_type, char > height_traits;

  const height_type&
  height () const;

  height_type&
  height ();

  void
  height (const height_type& x);

  // width
  // 
  typedef ::xml_schema::integer width_type;
  typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

  const width_type&
  width () const;

  width_type&
  width ();

  void
  width (const width_type& x);

  // x
  // 
  typedef ::xml_schema::integer x_type;
  typedef ::xsd::cxx::tree::traits< x_type, char > x_traits;

  const x_type&
  x () const;

  x_type&
  x ();

  void
  x (const x_type& x);

  // y
  // 
  typedef ::xml_schema::integer y_type;
  typedef ::xsd::cxx::tree::traits< y_type, char > y_traits;

  const y_type&
  y () const;

  y_type&
  y ();

  void
  y (const y_type& x);

  // Constructors.
  //
  labels_t (const text_type&,
            const border_type&,
            const height_type&,
            const width_type&,
            const x_type&,
            const y_type&);

  labels_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  labels_t (const labels_t& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual labels_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~labels_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< text_type > text_;
  ::xsd::cxx::tree::one< border_type > border_;
  ::xsd::cxx::tree::one< height_type > height_;
  ::xsd::cxx::tree::one< width_type > width_;
  ::xsd::cxx::tree::one< x_type > x_;
  ::xsd::cxx::tree::one< y_type > y_;
};

class place_t: public ::xml_schema::type
{
  public:
  // graphics
  // 
  typedef ::graphics_t graphics_type;
  typedef ::xsd::cxx::tree::traits< graphics_type, char > graphics_traits;

  const graphics_type&
  graphics () const;

  graphics_type&
  graphics ();

  void
  graphics (const graphics_type& x);

  void
  graphics (::std::auto_ptr< graphics_type > p);

  // name
  // 
  typedef ::name_t name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::auto_ptr< name_type > p);

  // initialMarking
  // 
  typedef ::initialMarking_t initialMarking_type;
  typedef ::xsd::cxx::tree::traits< initialMarking_type, char > initialMarking_traits;

  const initialMarking_type&
  initialMarking () const;

  initialMarking_type&
  initialMarking ();

  void
  initialMarking (const initialMarking_type& x);

  void
  initialMarking (::std::auto_ptr< initialMarking_type > p);

  // capacity
  // 
  typedef ::capacity_t capacity_type;
  typedef ::xsd::cxx::tree::traits< capacity_type, char > capacity_traits;

  const capacity_type&
  capacity () const;

  capacity_type&
  capacity ();

  void
  capacity (const capacity_type& x);

  void
  capacity (::std::auto_ptr< capacity_type > p);

  // toolspecific
  // 
  typedef ::toolspecific_t toolspecific_type;
  typedef ::xsd::cxx::tree::sequence< toolspecific_type > toolspecific_sequence;
  typedef toolspecific_sequence::iterator toolspecific_iterator;
  typedef toolspecific_sequence::const_iterator toolspecific_const_iterator;
  typedef ::xsd::cxx::tree::traits< toolspecific_type, char > toolspecific_traits;

  const toolspecific_sequence&
  toolspecific () const;

  toolspecific_sequence&
  toolspecific ();

  void
  toolspecific (const toolspecific_sequence& s);

  // id
  // 
  typedef ::xml_schema::ncname id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // Constructors.
  //
  place_t (const graphics_type&,
           const name_type&,
           const initialMarking_type&,
           const capacity_type&,
           const id_type&);

  place_t (::std::auto_ptr< graphics_type >&,
           ::std::auto_ptr< name_type >&,
           ::std::auto_ptr< initialMarking_type >&,
           ::std::auto_ptr< capacity_type >&,
           const id_type&);

  place_t (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  place_t (const place_t& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual place_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~place_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< graphics_type > graphics_;
  ::xsd::cxx::tree::one< name_type > name_;
  ::xsd::cxx::tree::one< initialMarking_type > initialMarking_;
  ::xsd::cxx::tree::one< capacity_type > capacity_;
  toolspecific_sequence toolspecific_;
  ::xsd::cxx::tree::one< id_type > id_;
};

class initialMarking_t: public ::xml_schema::type
{
  public:
  // value
  // 
  typedef ::xml_schema::non_negative_integer value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  // graphics
  // 
  typedef ::graphics_t graphics_type;
  typedef ::xsd::cxx::tree::traits< graphics_type, char > graphics_traits;

  const graphics_type&
  graphics () const;

  graphics_type&
  graphics ();

  void
  graphics (const graphics_type& x);

  void
  graphics (::std::auto_ptr< graphics_type > p);

  // Constructors.
  //
  initialMarking_t (const value_type&,
                    const graphics_type&);

  initialMarking_t (const value_type&,
                    ::std::auto_ptr< graphics_type >&);

  initialMarking_t (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  initialMarking_t (const initialMarking_t& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual initialMarking_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~initialMarking_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< value_type > value_;
  ::xsd::cxx::tree::one< graphics_type > graphics_;
};

class capacity_t: public ::xml_schema::type
{
  public:
  // value
  // 
  typedef ::xml_schema::non_negative_integer value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  // Constructors.
  //
  capacity_t (const value_type&);

  capacity_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  capacity_t (const capacity_t& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual capacity_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~capacity_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< value_type > value_;
};

class trajectory_t: public ::xml_schema::type
{
  public:
  // robot
  // 
  typedef ::xml_schema::string robot_type;
  typedef ::xsd::cxx::tree::traits< robot_type, char > robot_traits;

  const robot_type&
  robot () const;

  robot_type&
  robot ();

  void
  robot (const robot_type& x);

  void
  robot (::std::auto_ptr< robot_type > p);

  // file
  // 
  typedef ::xml_schema::string file_type;
  typedef ::xsd::cxx::tree::traits< file_type, char > file_traits;

  const file_type&
  file () const;

  file_type&
  file ();

  void
  file (const file_type& x);

  void
  file (::std::auto_ptr< file_type > p);

  // Constructors.
  //
  trajectory_t (const robot_type&,
                const file_type&);

  trajectory_t (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  trajectory_t (const trajectory_t& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual trajectory_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~trajectory_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< robot_type > robot_;
  ::xsd::cxx::tree::one< file_type > file_;
};

class toolspecific_t: public ::xml_schema::type
{
  public:
  // task
  // 
  typedef ::task_t task_type;
  typedef ::xsd::cxx::tree::sequence< task_type > task_sequence;
  typedef task_sequence::iterator task_iterator;
  typedef task_sequence::const_iterator task_const_iterator;
  typedef ::xsd::cxx::tree::traits< task_type, char > task_traits;

  const task_sequence&
  task () const;

  task_sequence&
  task ();

  void
  task (const task_sequence& s);

  // tool
  // 
  typedef ::xml_schema::string tool_type;
  typedef ::xsd::cxx::tree::traits< tool_type, char > tool_traits;

  const tool_type&
  tool () const;

  tool_type&
  tool ();

  void
  tool (const tool_type& x);

  void
  tool (::std::auto_ptr< tool_type > p);

  // version
  // 
  typedef ::xml_schema::string version_type;
  typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

  const version_type&
  version () const;

  version_type&
  version ();

  void
  version (const version_type& x);

  void
  version (::std::auto_ptr< version_type > p);

  // Constructors.
  //
  toolspecific_t (const tool_type&,
                  const version_type&);

  toolspecific_t (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  toolspecific_t (const toolspecific_t& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual toolspecific_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~toolspecific_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  task_sequence task_;
  ::xsd::cxx::tree::one< tool_type > tool_;
  ::xsd::cxx::tree::one< version_type > version_;
};

class transition_t: public ::xml_schema::type
{
  public:
  // graphics
  // 
  typedef ::graphics_t graphics_type;
  typedef ::xsd::cxx::tree::traits< graphics_type, char > graphics_traits;

  const graphics_type&
  graphics () const;

  graphics_type&
  graphics ();

  void
  graphics (const graphics_type& x);

  void
  graphics (::std::auto_ptr< graphics_type > p);

  // name
  // 
  typedef ::name_t name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::auto_ptr< name_type > p);

  // orientation
  // 
  typedef ::orientation_t orientation_type;
  typedef ::xsd::cxx::tree::traits< orientation_type, char > orientation_traits;

  const orientation_type&
  orientation () const;

  orientation_type&
  orientation ();

  void
  orientation (const orientation_type& x);

  void
  orientation (::std::auto_ptr< orientation_type > p);

  // rate
  // 
  typedef ::rate_t rate_type;
  typedef ::xsd::cxx::tree::traits< rate_type, char > rate_traits;

  const rate_type&
  rate () const;

  rate_type&
  rate ();

  void
  rate (const rate_type& x);

  void
  rate (::std::auto_ptr< rate_type > p);

  // timed
  // 
  typedef ::timed_t timed_type;
  typedef ::xsd::cxx::tree::traits< timed_type, char > timed_traits;

  const timed_type&
  timed () const;

  timed_type&
  timed ();

  void
  timed (const timed_type& x);

  void
  timed (::std::auto_ptr< timed_type > p);

  // infiniteServer
  // 
  typedef ::infiniteServer_t infiniteServer_type;
  typedef ::xsd::cxx::tree::traits< infiniteServer_type, char > infiniteServer_traits;

  const infiniteServer_type&
  infiniteServer () const;

  infiniteServer_type&
  infiniteServer ();

  void
  infiniteServer (const infiniteServer_type& x);

  void
  infiniteServer (::std::auto_ptr< infiniteServer_type > p);

  // priority
  // 
  typedef ::priority_t priority_type;
  typedef ::xsd::cxx::tree::traits< priority_type, char > priority_traits;

  const priority_type&
  priority () const;

  priority_type&
  priority ();

  void
  priority (const priority_type& x);

  void
  priority (::std::auto_ptr< priority_type > p);

  // toolspecific
  // 
  typedef ::toolspecific_t toolspecific_type;
  typedef ::xsd::cxx::tree::optional< toolspecific_type > toolspecific_optional;
  typedef ::xsd::cxx::tree::traits< toolspecific_type, char > toolspecific_traits;

  const toolspecific_optional&
  toolspecific () const;

  toolspecific_optional&
  toolspecific ();

  void
  toolspecific (const toolspecific_type& x);

  void
  toolspecific (const toolspecific_optional& x);

  void
  toolspecific (::std::auto_ptr< toolspecific_type > p);

  // id
  // 
  typedef ::xml_schema::ncname id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // Constructors.
  //
  transition_t (const graphics_type&,
                const name_type&,
                const orientation_type&,
                const rate_type&,
                const timed_type&,
                const infiniteServer_type&,
                const priority_type&,
                const id_type&);

  transition_t (::std::auto_ptr< graphics_type >&,
                ::std::auto_ptr< name_type >&,
                ::std::auto_ptr< orientation_type >&,
                ::std::auto_ptr< rate_type >&,
                ::std::auto_ptr< timed_type >&,
                ::std::auto_ptr< infiniteServer_type >&,
                ::std::auto_ptr< priority_type >&,
                const id_type&);

  transition_t (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  transition_t (const transition_t& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual transition_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~transition_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< graphics_type > graphics_;
  ::xsd::cxx::tree::one< name_type > name_;
  ::xsd::cxx::tree::one< orientation_type > orientation_;
  ::xsd::cxx::tree::one< rate_type > rate_;
  ::xsd::cxx::tree::one< timed_type > timed_;
  ::xsd::cxx::tree::one< infiniteServer_type > infiniteServer_;
  ::xsd::cxx::tree::one< priority_type > priority_;
  toolspecific_optional toolspecific_;
  ::xsd::cxx::tree::one< id_type > id_;
};

class orientation_t: public ::xml_schema::type
{
  public:
  // value
  // 
  typedef ::xml_schema::non_negative_integer value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  // Constructors.
  //
  orientation_t (const value_type&);

  orientation_t (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  orientation_t (const orientation_t& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual orientation_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~orientation_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< value_type > value_;
};

class rate_t: public ::xml_schema::type
{
  public:
  // value
  // 
  typedef ::xml_schema::float_ value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  // Constructors.
  //
  rate_t (const value_type&);

  rate_t (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  rate_t (const rate_t& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual rate_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~rate_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< value_type > value_;
};

class timed_t: public ::xml_schema::type
{
  public:
  // value
  // 
  typedef ::xml_schema::boolean value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  // Constructors.
  //
  timed_t (const value_type&);

  timed_t (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  timed_t (const timed_t& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual timed_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~timed_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< value_type > value_;
};

class infiniteServer_t: public ::xml_schema::type
{
  public:
  // value
  // 
  typedef ::xml_schema::boolean value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  // Constructors.
  //
  infiniteServer_t (const value_type&);

  infiniteServer_t (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  infiniteServer_t (const infiniteServer_t& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual infiniteServer_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~infiniteServer_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< value_type > value_;
};

class priority_t: public ::xml_schema::type
{
  public:
  // value
  // 
  typedef ::xml_schema::non_negative_integer value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  // Constructors.
  //
  priority_t (const value_type&);

  priority_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  priority_t (const priority_t& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual priority_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~priority_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< value_type > value_;
};

class arc_t: public ::xml_schema::type
{
  public:
  // graphics
  // 
  typedef ::graphics_t graphics_type;
  typedef ::xsd::cxx::tree::traits< graphics_type, char > graphics_traits;

  const graphics_type&
  graphics () const;

  graphics_type&
  graphics ();

  void
  graphics (const graphics_type& x);

  void
  graphics (::std::auto_ptr< graphics_type > p);

  // inscription
  // 
  typedef ::inscription_t inscription_type;
  typedef ::xsd::cxx::tree::traits< inscription_type, char > inscription_traits;

  const inscription_type&
  inscription () const;

  inscription_type&
  inscription ();

  void
  inscription (const inscription_type& x);

  void
  inscription (::std::auto_ptr< inscription_type > p);

  // tagged
  // 
  typedef ::tagged_t tagged_type;
  typedef ::xsd::cxx::tree::traits< tagged_type, char > tagged_traits;

  const tagged_type&
  tagged () const;

  tagged_type&
  tagged ();

  void
  tagged (const tagged_type& x);

  void
  tagged (::std::auto_ptr< tagged_type > p);

  // arcpath
  // 
  typedef ::arcpath_t arcpath_type;
  typedef ::xsd::cxx::tree::sequence< arcpath_type > arcpath_sequence;
  typedef arcpath_sequence::iterator arcpath_iterator;
  typedef arcpath_sequence::const_iterator arcpath_const_iterator;
  typedef ::xsd::cxx::tree::traits< arcpath_type, char > arcpath_traits;

  const arcpath_sequence&
  arcpath () const;

  arcpath_sequence&
  arcpath ();

  void
  arcpath (const arcpath_sequence& s);

  // type
  // 
  typedef ::type_t type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // id
  // 
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // source
  // 
  typedef ::xml_schema::ncname source_type;
  typedef ::xsd::cxx::tree::traits< source_type, char > source_traits;

  const source_type&
  source () const;

  source_type&
  source ();

  void
  source (const source_type& x);

  void
  source (::std::auto_ptr< source_type > p);

  // target
  // 
  typedef ::xml_schema::ncname target_type;
  typedef ::xsd::cxx::tree::traits< target_type, char > target_traits;

  const target_type&
  target () const;

  target_type&
  target ();

  void
  target (const target_type& x);

  void
  target (::std::auto_ptr< target_type > p);

  // Constructors.
  //
  arc_t (const graphics_type&,
         const inscription_type&,
         const tagged_type&,
         const type_type&,
         const id_type&,
         const source_type&,
         const target_type&);

  arc_t (::std::auto_ptr< graphics_type >&,
         ::std::auto_ptr< inscription_type >&,
         ::std::auto_ptr< tagged_type >&,
         ::std::auto_ptr< type_type >&,
         const id_type&,
         const source_type&,
         const target_type&);

  arc_t (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  arc_t (const arc_t& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual arc_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~arc_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< graphics_type > graphics_;
  ::xsd::cxx::tree::one< inscription_type > inscription_;
  ::xsd::cxx::tree::one< tagged_type > tagged_;
  arcpath_sequence arcpath_;
  ::xsd::cxx::tree::one< type_type > type_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< source_type > source_;
  ::xsd::cxx::tree::one< target_type > target_;
};

class inscription_t: public ::xml_schema::type
{
  public:
  // value
  // 
  typedef ::xml_schema::non_negative_integer value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  // graphics
  // 
  typedef ::graphics_t graphics_type;
  typedef ::xsd::cxx::tree::traits< graphics_type, char > graphics_traits;

  const graphics_type&
  graphics () const;

  graphics_type&
  graphics ();

  void
  graphics (const graphics_type& x);

  void
  graphics (::std::auto_ptr< graphics_type > p);

  // Constructors.
  //
  inscription_t (const value_type&,
                 const graphics_type&);

  inscription_t (const value_type&,
                 ::std::auto_ptr< graphics_type >&);

  inscription_t (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  inscription_t (const inscription_t& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual inscription_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~inscription_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< value_type > value_;
  ::xsd::cxx::tree::one< graphics_type > graphics_;
};

class tagged_t: public ::xml_schema::type
{
  public:
  // value
  // 
  typedef ::xml_schema::boolean value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  // Constructors.
  //
  tagged_t (const value_type&);

  tagged_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  tagged_t (const tagged_t& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual tagged_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~tagged_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< value_type > value_;
};

class arcpath_t: public ::xml_schema::type
{
  public:
  // curvePoint
  // 
  typedef ::xml_schema::boolean curvePoint_type;
  typedef ::xsd::cxx::tree::traits< curvePoint_type, char > curvePoint_traits;

  const curvePoint_type&
  curvePoint () const;

  curvePoint_type&
  curvePoint ();

  void
  curvePoint (const curvePoint_type& x);

  // id
  // 
  typedef ::xml_schema::integer id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  // x
  // 
  typedef ::xml_schema::integer x_type;
  typedef ::xsd::cxx::tree::traits< x_type, char > x_traits;

  const x_type&
  x () const;

  x_type&
  x ();

  void
  x (const x_type& x);

  // y
  // 
  typedef ::xml_schema::integer y_type;
  typedef ::xsd::cxx::tree::traits< y_type, char > y_traits;

  const y_type&
  y () const;

  y_type&
  y ();

  void
  y (const y_type& x);

  // Constructors.
  //
  arcpath_t (const curvePoint_type&,
             const id_type&,
             const x_type&,
             const y_type&);

  arcpath_t (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  arcpath_t (const arcpath_t& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual arcpath_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~arcpath_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< curvePoint_type > curvePoint_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< x_type > x_;
  ::xsd::cxx::tree::one< y_type > y_;
};

class type_t: public ::xml_schema::type
{
  public:
  // value
  // 
  typedef ::xml_schema::ncname value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  void
  value (::std::auto_ptr< value_type > p);

  // Constructors.
  //
  type_t (const value_type&);

  type_t (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  type_t (const type_t& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual type_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~type_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< value_type > value_;
};

class graphics_t: public ::xml_schema::type
{
  public:
  // offset
  // 
  typedef ::offset_t offset_type;
  typedef ::xsd::cxx::tree::optional< offset_type > offset_optional;
  typedef ::xsd::cxx::tree::traits< offset_type, char > offset_traits;

  const offset_optional&
  offset () const;

  offset_optional&
  offset ();

  void
  offset (const offset_type& x);

  void
  offset (const offset_optional& x);

  void
  offset (::std::auto_ptr< offset_type > p);

  // position
  // 
  typedef ::position_t position_type;
  typedef ::xsd::cxx::tree::optional< position_type > position_optional;
  typedef ::xsd::cxx::tree::traits< position_type, char > position_traits;

  const position_optional&
  position () const;

  position_optional&
  position ();

  void
  position (const position_type& x);

  void
  position (const position_optional& x);

  void
  position (::std::auto_ptr< position_type > p);

  // Constructors.
  //
  graphics_t ();

  graphics_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  graphics_t (const graphics_t& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual graphics_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~graphics_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  offset_optional offset_;
  position_optional position_;
};

class offset_t: public ::xml_schema::type
{
  public:
  // x
  // 
  typedef ::xml_schema::decimal x_type;
  typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::decimal > x_traits;

  const x_type&
  x () const;

  x_type&
  x ();

  void
  x (const x_type& x);

  // y
  // 
  typedef ::xml_schema::decimal y_type;
  typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::decimal > y_traits;

  const y_type&
  y () const;

  y_type&
  y ();

  void
  y (const y_type& x);

  // Constructors.
  //
  offset_t (const x_type&,
            const y_type&);

  offset_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  offset_t (const offset_t& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual offset_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~offset_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< x_type > x_;
  ::xsd::cxx::tree::one< y_type > y_;
};

class position_t: public ::xml_schema::type
{
  public:
  // x
  // 
  typedef ::xml_schema::decimal x_type;
  typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::decimal > x_traits;

  const x_type&
  x () const;

  x_type&
  x ();

  void
  x (const x_type& x);

  // y
  // 
  typedef ::xml_schema::decimal y_type;
  typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::decimal > y_traits;

  const y_type&
  y () const;

  y_type&
  y ();

  void
  y (const y_type& x);

  // Constructors.
  //
  position_t (const x_type&,
              const y_type&);

  position_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  position_t (const position_t& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual position_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~position_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< x_type > x_;
  ::xsd::cxx::tree::one< y_type > y_;
};

class name_t: public ::xml_schema::type
{
  public:
  // value
  // 
  typedef ::xml_schema::string value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  void
  value (::std::auto_ptr< value_type > p);

  // graphics
  // 
  typedef ::graphics_t graphics_type;
  typedef ::xsd::cxx::tree::traits< graphics_type, char > graphics_traits;

  const graphics_type&
  graphics () const;

  graphics_type&
  graphics ();

  void
  graphics (const graphics_type& x);

  void
  graphics (::std::auto_ptr< graphics_type > p);

  // Constructors.
  //
  name_t (const value_type&,
          const graphics_type&);

  name_t (const value_type&,
          ::std::auto_ptr< graphics_type >&);

  name_t (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  name_t (const name_t& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual name_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~name_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< value_type > value_;
  ::xsd::cxx::tree::one< graphics_type > graphics_;
};

class name1_t: public ::xml_schema::type
{
  public:
  // value
  // 
  typedef ::xml_schema::string value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  void
  value (::std::auto_ptr< value_type > p);

  // Constructors.
  //
  name1_t (const value_type&);

  name1_t (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  name1_t (const name1_t& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual name1_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~name1_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< value_type > value_;
};

class task_t: public ::xml_schema::type
{
  public:
  // exec
  // 
  typedef ::xml_schema::string exec_type;
  typedef ::xsd::cxx::tree::optional< exec_type > exec_optional;
  typedef ::xsd::cxx::tree::traits< exec_type, char > exec_traits;

  const exec_optional&
  exec () const;

  exec_optional&
  exec ();

  void
  exec (const exec_type& x);

  void
  exec (const exec_optional& x);

  void
  exec (::std::auto_ptr< exec_type > p);

  // trajectory
  // 
  typedef ::trajectory_t trajectory_type;
  typedef ::xsd::cxx::tree::optional< trajectory_type > trajectory_optional;
  typedef ::xsd::cxx::tree::traits< trajectory_type, char > trajectory_traits;

  const trajectory_optional&
  trajectory () const;

  trajectory_optional&
  trajectory ();

  void
  trajectory (const trajectory_type& x);

  void
  trajectory (const trajectory_optional& x);

  void
  trajectory (::std::auto_ptr< trajectory_type > p);

  // Constructors.
  //
  task_t ();

  task_t (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  task_t (const task_t& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual task_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~task_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  exec_optional exec_;
  trajectory_optional trajectory_;
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::pnml_t >
pnml (const ::std::string& uri,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::pnml_t >
pnml (const ::std::string& uri,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::pnml_t >
pnml (const ::std::string& uri,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::pnml_t >
pnml (::std::istream& is,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::pnml_t >
pnml (::std::istream& is,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::pnml_t >
pnml (::std::istream& is,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::pnml_t >
pnml (::std::istream& is,
      const ::std::string& id,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::pnml_t >
pnml (::std::istream& is,
      const ::std::string& id,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::pnml_t >
pnml (::std::istream& is,
      const ::std::string& id,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::pnml_t >
pnml (::xercesc::InputSource& is,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::pnml_t >
pnml (::xercesc::InputSource& is,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::pnml_t >
pnml (::xercesc::InputSource& is,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::pnml_t >
pnml (const ::xercesc::DOMDocument& d,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::pnml_t >
pnml (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // PIPEPNML_HXX
