// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "pipepnml.hxx"

// value_t
// 

const value_t::value1_type& value_t::
value1 () const
{
  return this->value1_.get ();
}

value_t::value1_type& value_t::
value1 ()
{
  return this->value1_.get ();
}

void value_t::
value1 (const value1_type& x)
{
  this->value1_.set (x);
}

void value_t::
value1 (::std::auto_ptr< value1_type > x)
{
  this->value1_.set (x);
}


// pnml_t
// 

const pnml_t::net_type& pnml_t::
net () const
{
  return this->net_.get ();
}

pnml_t::net_type& pnml_t::
net ()
{
  return this->net_.get ();
}

void pnml_t::
net (const net_type& x)
{
  this->net_.set (x);
}

void pnml_t::
net (::std::auto_ptr< net_type > x)
{
  this->net_.set (x);
}


// net_t
// 

const net_t::name_optional& net_t::
name () const
{
  return this->name_;
}

net_t::name_optional& net_t::
name ()
{
  return this->name_;
}

void net_t::
name (const name_type& x)
{
  this->name_.set (x);
}

void net_t::
name (const name_optional& x)
{
  this->name_ = x;
}

void net_t::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const net_t::labels_sequence& net_t::
labels () const
{
  return this->labels_;
}

net_t::labels_sequence& net_t::
labels ()
{
  return this->labels_;
}

void net_t::
labels (const labels_sequence& s)
{
  this->labels_ = s;
}

const net_t::place_sequence& net_t::
place () const
{
  return this->place_;
}

net_t::place_sequence& net_t::
place ()
{
  return this->place_;
}

void net_t::
place (const place_sequence& s)
{
  this->place_ = s;
}

const net_t::transition_sequence& net_t::
transition () const
{
  return this->transition_;
}

net_t::transition_sequence& net_t::
transition ()
{
  return this->transition_;
}

void net_t::
transition (const transition_sequence& s)
{
  this->transition_ = s;
}

const net_t::arc_sequence& net_t::
arc () const
{
  return this->arc_;
}

net_t::arc_sequence& net_t::
arc ()
{
  return this->arc_;
}

void net_t::
arc (const arc_sequence& s)
{
  this->arc_ = s;
}

const net_t::id_type& net_t::
id () const
{
  return this->id_.get ();
}

net_t::id_type& net_t::
id ()
{
  return this->id_.get ();
}

void net_t::
id (const id_type& x)
{
  this->id_.set (x);
}

void net_t::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const net_t::type_type& net_t::
type () const
{
  return this->type_.get ();
}

net_t::type_type& net_t::
type ()
{
  return this->type_.get ();
}

void net_t::
type (const type_type& x)
{
  this->type_.set (x);
}

void net_t::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}


// labels_t
// 

const labels_t::text_type& labels_t::
text () const
{
  return this->text_.get ();
}

labels_t::text_type& labels_t::
text ()
{
  return this->text_.get ();
}

void labels_t::
text (const text_type& x)
{
  this->text_.set (x);
}

void labels_t::
text (::std::auto_ptr< text_type > x)
{
  this->text_.set (x);
}

const labels_t::border_type& labels_t::
border () const
{
  return this->border_.get ();
}

labels_t::border_type& labels_t::
border ()
{
  return this->border_.get ();
}

void labels_t::
border (const border_type& x)
{
  this->border_.set (x);
}

const labels_t::height_type& labels_t::
height () const
{
  return this->height_.get ();
}

labels_t::height_type& labels_t::
height ()
{
  return this->height_.get ();
}

void labels_t::
height (const height_type& x)
{
  this->height_.set (x);
}

const labels_t::width_type& labels_t::
width () const
{
  return this->width_.get ();
}

labels_t::width_type& labels_t::
width ()
{
  return this->width_.get ();
}

void labels_t::
width (const width_type& x)
{
  this->width_.set (x);
}

const labels_t::x_type& labels_t::
x () const
{
  return this->x_.get ();
}

labels_t::x_type& labels_t::
x ()
{
  return this->x_.get ();
}

void labels_t::
x (const x_type& x)
{
  this->x_.set (x);
}

const labels_t::y_type& labels_t::
y () const
{
  return this->y_.get ();
}

labels_t::y_type& labels_t::
y ()
{
  return this->y_.get ();
}

void labels_t::
y (const y_type& x)
{
  this->y_.set (x);
}


// place_t
// 

const place_t::graphics_type& place_t::
graphics () const
{
  return this->graphics_.get ();
}

place_t::graphics_type& place_t::
graphics ()
{
  return this->graphics_.get ();
}

void place_t::
graphics (const graphics_type& x)
{
  this->graphics_.set (x);
}

void place_t::
graphics (::std::auto_ptr< graphics_type > x)
{
  this->graphics_.set (x);
}

const place_t::name_type& place_t::
name () const
{
  return this->name_.get ();
}

place_t::name_type& place_t::
name ()
{
  return this->name_.get ();
}

void place_t::
name (const name_type& x)
{
  this->name_.set (x);
}

void place_t::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const place_t::initialMarking_type& place_t::
initialMarking () const
{
  return this->initialMarking_.get ();
}

place_t::initialMarking_type& place_t::
initialMarking ()
{
  return this->initialMarking_.get ();
}

void place_t::
initialMarking (const initialMarking_type& x)
{
  this->initialMarking_.set (x);
}

void place_t::
initialMarking (::std::auto_ptr< initialMarking_type > x)
{
  this->initialMarking_.set (x);
}

const place_t::capacity_type& place_t::
capacity () const
{
  return this->capacity_.get ();
}

place_t::capacity_type& place_t::
capacity ()
{
  return this->capacity_.get ();
}

void place_t::
capacity (const capacity_type& x)
{
  this->capacity_.set (x);
}

void place_t::
capacity (::std::auto_ptr< capacity_type > x)
{
  this->capacity_.set (x);
}

const place_t::toolspecific_sequence& place_t::
toolspecific () const
{
  return this->toolspecific_;
}

place_t::toolspecific_sequence& place_t::
toolspecific ()
{
  return this->toolspecific_;
}

void place_t::
toolspecific (const toolspecific_sequence& s)
{
  this->toolspecific_ = s;
}

const place_t::id_type& place_t::
id () const
{
  return this->id_.get ();
}

place_t::id_type& place_t::
id ()
{
  return this->id_.get ();
}

void place_t::
id (const id_type& x)
{
  this->id_.set (x);
}

void place_t::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}


// initialMarking_t
// 

const initialMarking_t::value_type& initialMarking_t::
value () const
{
  return this->value_.get ();
}

initialMarking_t::value_type& initialMarking_t::
value ()
{
  return this->value_.get ();
}

void initialMarking_t::
value (const value_type& x)
{
  this->value_.set (x);
}

const initialMarking_t::graphics_type& initialMarking_t::
graphics () const
{
  return this->graphics_.get ();
}

initialMarking_t::graphics_type& initialMarking_t::
graphics ()
{
  return this->graphics_.get ();
}

void initialMarking_t::
graphics (const graphics_type& x)
{
  this->graphics_.set (x);
}

void initialMarking_t::
graphics (::std::auto_ptr< graphics_type > x)
{
  this->graphics_.set (x);
}


// capacity_t
// 

const capacity_t::value_type& capacity_t::
value () const
{
  return this->value_.get ();
}

capacity_t::value_type& capacity_t::
value ()
{
  return this->value_.get ();
}

void capacity_t::
value (const value_type& x)
{
  this->value_.set (x);
}


// trajectory_t
// 

const trajectory_t::robot_type& trajectory_t::
robot () const
{
  return this->robot_.get ();
}

trajectory_t::robot_type& trajectory_t::
robot ()
{
  return this->robot_.get ();
}

void trajectory_t::
robot (const robot_type& x)
{
  this->robot_.set (x);
}

void trajectory_t::
robot (::std::auto_ptr< robot_type > x)
{
  this->robot_.set (x);
}

const trajectory_t::file_type& trajectory_t::
file () const
{
  return this->file_.get ();
}

trajectory_t::file_type& trajectory_t::
file ()
{
  return this->file_.get ();
}

void trajectory_t::
file (const file_type& x)
{
  this->file_.set (x);
}

void trajectory_t::
file (::std::auto_ptr< file_type > x)
{
  this->file_.set (x);
}


// toolspecific_t
// 

const toolspecific_t::task_sequence& toolspecific_t::
task () const
{
  return this->task_;
}

toolspecific_t::task_sequence& toolspecific_t::
task ()
{
  return this->task_;
}

void toolspecific_t::
task (const task_sequence& s)
{
  this->task_ = s;
}

const toolspecific_t::tool_type& toolspecific_t::
tool () const
{
  return this->tool_.get ();
}

toolspecific_t::tool_type& toolspecific_t::
tool ()
{
  return this->tool_.get ();
}

void toolspecific_t::
tool (const tool_type& x)
{
  this->tool_.set (x);
}

void toolspecific_t::
tool (::std::auto_ptr< tool_type > x)
{
  this->tool_.set (x);
}

const toolspecific_t::version_type& toolspecific_t::
version () const
{
  return this->version_.get ();
}

toolspecific_t::version_type& toolspecific_t::
version ()
{
  return this->version_.get ();
}

void toolspecific_t::
version (const version_type& x)
{
  this->version_.set (x);
}

void toolspecific_t::
version (::std::auto_ptr< version_type > x)
{
  this->version_.set (x);
}


// transition_t
// 

const transition_t::graphics_type& transition_t::
graphics () const
{
  return this->graphics_.get ();
}

transition_t::graphics_type& transition_t::
graphics ()
{
  return this->graphics_.get ();
}

void transition_t::
graphics (const graphics_type& x)
{
  this->graphics_.set (x);
}

void transition_t::
graphics (::std::auto_ptr< graphics_type > x)
{
  this->graphics_.set (x);
}

const transition_t::name_type& transition_t::
name () const
{
  return this->name_.get ();
}

transition_t::name_type& transition_t::
name ()
{
  return this->name_.get ();
}

void transition_t::
name (const name_type& x)
{
  this->name_.set (x);
}

void transition_t::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const transition_t::orientation_type& transition_t::
orientation () const
{
  return this->orientation_.get ();
}

transition_t::orientation_type& transition_t::
orientation ()
{
  return this->orientation_.get ();
}

void transition_t::
orientation (const orientation_type& x)
{
  this->orientation_.set (x);
}

void transition_t::
orientation (::std::auto_ptr< orientation_type > x)
{
  this->orientation_.set (x);
}

const transition_t::rate_type& transition_t::
rate () const
{
  return this->rate_.get ();
}

transition_t::rate_type& transition_t::
rate ()
{
  return this->rate_.get ();
}

void transition_t::
rate (const rate_type& x)
{
  this->rate_.set (x);
}

void transition_t::
rate (::std::auto_ptr< rate_type > x)
{
  this->rate_.set (x);
}

const transition_t::timed_type& transition_t::
timed () const
{
  return this->timed_.get ();
}

transition_t::timed_type& transition_t::
timed ()
{
  return this->timed_.get ();
}

void transition_t::
timed (const timed_type& x)
{
  this->timed_.set (x);
}

void transition_t::
timed (::std::auto_ptr< timed_type > x)
{
  this->timed_.set (x);
}

const transition_t::infiniteServer_type& transition_t::
infiniteServer () const
{
  return this->infiniteServer_.get ();
}

transition_t::infiniteServer_type& transition_t::
infiniteServer ()
{
  return this->infiniteServer_.get ();
}

void transition_t::
infiniteServer (const infiniteServer_type& x)
{
  this->infiniteServer_.set (x);
}

void transition_t::
infiniteServer (::std::auto_ptr< infiniteServer_type > x)
{
  this->infiniteServer_.set (x);
}

const transition_t::priority_type& transition_t::
priority () const
{
  return this->priority_.get ();
}

transition_t::priority_type& transition_t::
priority ()
{
  return this->priority_.get ();
}

void transition_t::
priority (const priority_type& x)
{
  this->priority_.set (x);
}

void transition_t::
priority (::std::auto_ptr< priority_type > x)
{
  this->priority_.set (x);
}

const transition_t::toolspecific_optional& transition_t::
toolspecific () const
{
  return this->toolspecific_;
}

transition_t::toolspecific_optional& transition_t::
toolspecific ()
{
  return this->toolspecific_;
}

void transition_t::
toolspecific (const toolspecific_type& x)
{
  this->toolspecific_.set (x);
}

void transition_t::
toolspecific (const toolspecific_optional& x)
{
  this->toolspecific_ = x;
}

void transition_t::
toolspecific (::std::auto_ptr< toolspecific_type > x)
{
  this->toolspecific_.set (x);
}

const transition_t::id_type& transition_t::
id () const
{
  return this->id_.get ();
}

transition_t::id_type& transition_t::
id ()
{
  return this->id_.get ();
}

void transition_t::
id (const id_type& x)
{
  this->id_.set (x);
}

void transition_t::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}


// orientation_t
// 

const orientation_t::value_type& orientation_t::
value () const
{
  return this->value_.get ();
}

orientation_t::value_type& orientation_t::
value ()
{
  return this->value_.get ();
}

void orientation_t::
value (const value_type& x)
{
  this->value_.set (x);
}


// rate_t
// 

const rate_t::value_type& rate_t::
value () const
{
  return this->value_.get ();
}

rate_t::value_type& rate_t::
value ()
{
  return this->value_.get ();
}

void rate_t::
value (const value_type& x)
{
  this->value_.set (x);
}


// timed_t
// 

const timed_t::value_type& timed_t::
value () const
{
  return this->value_.get ();
}

timed_t::value_type& timed_t::
value ()
{
  return this->value_.get ();
}

void timed_t::
value (const value_type& x)
{
  this->value_.set (x);
}


// infiniteServer_t
// 

const infiniteServer_t::value_type& infiniteServer_t::
value () const
{
  return this->value_.get ();
}

infiniteServer_t::value_type& infiniteServer_t::
value ()
{
  return this->value_.get ();
}

void infiniteServer_t::
value (const value_type& x)
{
  this->value_.set (x);
}


// priority_t
// 

const priority_t::value_type& priority_t::
value () const
{
  return this->value_.get ();
}

priority_t::value_type& priority_t::
value ()
{
  return this->value_.get ();
}

void priority_t::
value (const value_type& x)
{
  this->value_.set (x);
}


// arc_t
// 

const arc_t::graphics_type& arc_t::
graphics () const
{
  return this->graphics_.get ();
}

arc_t::graphics_type& arc_t::
graphics ()
{
  return this->graphics_.get ();
}

void arc_t::
graphics (const graphics_type& x)
{
  this->graphics_.set (x);
}

void arc_t::
graphics (::std::auto_ptr< graphics_type > x)
{
  this->graphics_.set (x);
}

const arc_t::inscription_type& arc_t::
inscription () const
{
  return this->inscription_.get ();
}

arc_t::inscription_type& arc_t::
inscription ()
{
  return this->inscription_.get ();
}

void arc_t::
inscription (const inscription_type& x)
{
  this->inscription_.set (x);
}

void arc_t::
inscription (::std::auto_ptr< inscription_type > x)
{
  this->inscription_.set (x);
}

const arc_t::tagged_type& arc_t::
tagged () const
{
  return this->tagged_.get ();
}

arc_t::tagged_type& arc_t::
tagged ()
{
  return this->tagged_.get ();
}

void arc_t::
tagged (const tagged_type& x)
{
  this->tagged_.set (x);
}

void arc_t::
tagged (::std::auto_ptr< tagged_type > x)
{
  this->tagged_.set (x);
}

const arc_t::arcpath_sequence& arc_t::
arcpath () const
{
  return this->arcpath_;
}

arc_t::arcpath_sequence& arc_t::
arcpath ()
{
  return this->arcpath_;
}

void arc_t::
arcpath (const arcpath_sequence& s)
{
  this->arcpath_ = s;
}

const arc_t::type_type& arc_t::
type () const
{
  return this->type_.get ();
}

arc_t::type_type& arc_t::
type ()
{
  return this->type_.get ();
}

void arc_t::
type (const type_type& x)
{
  this->type_.set (x);
}

void arc_t::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const arc_t::id_type& arc_t::
id () const
{
  return this->id_.get ();
}

arc_t::id_type& arc_t::
id ()
{
  return this->id_.get ();
}

void arc_t::
id (const id_type& x)
{
  this->id_.set (x);
}

void arc_t::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const arc_t::source_type& arc_t::
source () const
{
  return this->source_.get ();
}

arc_t::source_type& arc_t::
source ()
{
  return this->source_.get ();
}

void arc_t::
source (const source_type& x)
{
  this->source_.set (x);
}

void arc_t::
source (::std::auto_ptr< source_type > x)
{
  this->source_.set (x);
}

const arc_t::target_type& arc_t::
target () const
{
  return this->target_.get ();
}

arc_t::target_type& arc_t::
target ()
{
  return this->target_.get ();
}

void arc_t::
target (const target_type& x)
{
  this->target_.set (x);
}

void arc_t::
target (::std::auto_ptr< target_type > x)
{
  this->target_.set (x);
}


// inscription_t
// 

const inscription_t::value_type& inscription_t::
value () const
{
  return this->value_.get ();
}

inscription_t::value_type& inscription_t::
value ()
{
  return this->value_.get ();
}

void inscription_t::
value (const value_type& x)
{
  this->value_.set (x);
}

const inscription_t::graphics_type& inscription_t::
graphics () const
{
  return this->graphics_.get ();
}

inscription_t::graphics_type& inscription_t::
graphics ()
{
  return this->graphics_.get ();
}

void inscription_t::
graphics (const graphics_type& x)
{
  this->graphics_.set (x);
}

void inscription_t::
graphics (::std::auto_ptr< graphics_type > x)
{
  this->graphics_.set (x);
}


// tagged_t
// 

const tagged_t::value_type& tagged_t::
value () const
{
  return this->value_.get ();
}

tagged_t::value_type& tagged_t::
value ()
{
  return this->value_.get ();
}

void tagged_t::
value (const value_type& x)
{
  this->value_.set (x);
}


// arcpath_t
// 

const arcpath_t::curvePoint_type& arcpath_t::
curvePoint () const
{
  return this->curvePoint_.get ();
}

arcpath_t::curvePoint_type& arcpath_t::
curvePoint ()
{
  return this->curvePoint_.get ();
}

void arcpath_t::
curvePoint (const curvePoint_type& x)
{
  this->curvePoint_.set (x);
}

const arcpath_t::id_type& arcpath_t::
id () const
{
  return this->id_.get ();
}

arcpath_t::id_type& arcpath_t::
id ()
{
  return this->id_.get ();
}

void arcpath_t::
id (const id_type& x)
{
  this->id_.set (x);
}

const arcpath_t::x_type& arcpath_t::
x () const
{
  return this->x_.get ();
}

arcpath_t::x_type& arcpath_t::
x ()
{
  return this->x_.get ();
}

void arcpath_t::
x (const x_type& x)
{
  this->x_.set (x);
}

const arcpath_t::y_type& arcpath_t::
y () const
{
  return this->y_.get ();
}

arcpath_t::y_type& arcpath_t::
y ()
{
  return this->y_.get ();
}

void arcpath_t::
y (const y_type& x)
{
  this->y_.set (x);
}


// type_t
// 

const type_t::value_type& type_t::
value () const
{
  return this->value_.get ();
}

type_t::value_type& type_t::
value ()
{
  return this->value_.get ();
}

void type_t::
value (const value_type& x)
{
  this->value_.set (x);
}

void type_t::
value (::std::auto_ptr< value_type > x)
{
  this->value_.set (x);
}


// graphics_t
// 

const graphics_t::offset_optional& graphics_t::
offset () const
{
  return this->offset_;
}

graphics_t::offset_optional& graphics_t::
offset ()
{
  return this->offset_;
}

void graphics_t::
offset (const offset_type& x)
{
  this->offset_.set (x);
}

void graphics_t::
offset (const offset_optional& x)
{
  this->offset_ = x;
}

void graphics_t::
offset (::std::auto_ptr< offset_type > x)
{
  this->offset_.set (x);
}

const graphics_t::position_optional& graphics_t::
position () const
{
  return this->position_;
}

graphics_t::position_optional& graphics_t::
position ()
{
  return this->position_;
}

void graphics_t::
position (const position_type& x)
{
  this->position_.set (x);
}

void graphics_t::
position (const position_optional& x)
{
  this->position_ = x;
}

void graphics_t::
position (::std::auto_ptr< position_type > x)
{
  this->position_.set (x);
}


// offset_t
// 

const offset_t::x_type& offset_t::
x () const
{
  return this->x_.get ();
}

offset_t::x_type& offset_t::
x ()
{
  return this->x_.get ();
}

void offset_t::
x (const x_type& x)
{
  this->x_.set (x);
}

const offset_t::y_type& offset_t::
y () const
{
  return this->y_.get ();
}

offset_t::y_type& offset_t::
y ()
{
  return this->y_.get ();
}

void offset_t::
y (const y_type& x)
{
  this->y_.set (x);
}


// position_t
// 

const position_t::x_type& position_t::
x () const
{
  return this->x_.get ();
}

position_t::x_type& position_t::
x ()
{
  return this->x_.get ();
}

void position_t::
x (const x_type& x)
{
  this->x_.set (x);
}

const position_t::y_type& position_t::
y () const
{
  return this->y_.get ();
}

position_t::y_type& position_t::
y ()
{
  return this->y_.get ();
}

void position_t::
y (const y_type& x)
{
  this->y_.set (x);
}


// name_t
// 

const name_t::value_type& name_t::
value () const
{
  return this->value_.get ();
}

name_t::value_type& name_t::
value ()
{
  return this->value_.get ();
}

void name_t::
value (const value_type& x)
{
  this->value_.set (x);
}

void name_t::
value (::std::auto_ptr< value_type > x)
{
  this->value_.set (x);
}

const name_t::graphics_type& name_t::
graphics () const
{
  return this->graphics_.get ();
}

name_t::graphics_type& name_t::
graphics ()
{
  return this->graphics_.get ();
}

void name_t::
graphics (const graphics_type& x)
{
  this->graphics_.set (x);
}

void name_t::
graphics (::std::auto_ptr< graphics_type > x)
{
  this->graphics_.set (x);
}


// name1_t
// 

const name1_t::value_type& name1_t::
value () const
{
  return this->value_.get ();
}

name1_t::value_type& name1_t::
value ()
{
  return this->value_.get ();
}

void name1_t::
value (const value_type& x)
{
  this->value_.set (x);
}

void name1_t::
value (::std::auto_ptr< value_type > x)
{
  this->value_.set (x);
}


// task_t
// 

const task_t::exec_optional& task_t::
exec () const
{
  return this->exec_;
}

task_t::exec_optional& task_t::
exec ()
{
  return this->exec_;
}

void task_t::
exec (const exec_type& x)
{
  this->exec_.set (x);
}

void task_t::
exec (const exec_optional& x)
{
  this->exec_ = x;
}

void task_t::
exec (::std::auto_ptr< exec_type > x)
{
  this->exec_.set (x);
}

const task_t::trajectory_optional& task_t::
trajectory () const
{
  return this->trajectory_;
}

task_t::trajectory_optional& task_t::
trajectory ()
{
  return this->trajectory_;
}

void task_t::
trajectory (const trajectory_type& x)
{
  this->trajectory_.set (x);
}

void task_t::
trajectory (const trajectory_optional& x)
{
  this->trajectory_ = x;
}

void task_t::
trajectory (::std::auto_ptr< trajectory_type > x)
{
  this->trajectory_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// value_t
//

value_t::
value_t (const value1_type& value1)
: ::xml_schema::type (),
  value1_ (value1, ::xml_schema::flags (), this)
{
}

value_t::
value_t (const value_t& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  value1_ (x.value1_, f, this)
{
}

value_t::
value_t (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  value1_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void value_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // value
    //
    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< value1_type > r (
        value1_traits::create (i, f, this));

      if (!value1_.present ())
      {
        this->value1_.set (r);
        continue;
      }
    }

    break;
  }

  if (!value1_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "value",
      "");
  }
}

value_t* value_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class value_t (*this, f, c);
}

value_t::
~value_t ()
{
}

// pnml_t
//

pnml_t::
pnml_t (const net_type& net)
: ::xml_schema::type (),
  net_ (net, ::xml_schema::flags (), this)
{
}

pnml_t::
pnml_t (::std::auto_ptr< net_type >& net)
: ::xml_schema::type (),
  net_ (net, ::xml_schema::flags (), this)
{
}

pnml_t::
pnml_t (const pnml_t& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  net_ (x.net_, f, this)
{
}

pnml_t::
pnml_t (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  net_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void pnml_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // net
    //
    if (n.name () == "net" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< net_type > r (
        net_traits::create (i, f, this));

      if (!net_.present ())
      {
        this->net_.set (r);
        continue;
      }
    }

    break;
  }

  if (!net_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "net",
      "");
  }
}

pnml_t* pnml_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class pnml_t (*this, f, c);
}

pnml_t::
~pnml_t ()
{
}

// net_t
//

net_t::
net_t (const id_type& id,
       const type_type& type)
: ::xml_schema::type (),
  name_ (::xml_schema::flags (), this),
  labels_ (::xml_schema::flags (), this),
  place_ (::xml_schema::flags (), this),
  transition_ (::xml_schema::flags (), this),
  arc_ (::xml_schema::flags (), this),
  id_ (id, ::xml_schema::flags (), this),
  type_ (type, ::xml_schema::flags (), this)
{
}

net_t::
net_t (const net_t& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  labels_ (x.labels_, f, this),
  place_ (x.place_, f, this),
  transition_ (x.transition_, f, this),
  arc_ (x.arc_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this)
{
}

net_t::
net_t (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (f, this),
  labels_ (f, this),
  place_ (f, this),
  transition_ (f, this),
  arc_ (f, this),
  id_ (f, this),
  type_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void net_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!this->name_)
      {
        this->name_.set (r);
        continue;
      }
    }

    // labels
    //
    if (n.name () == "labels" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< labels_type > r (
        labels_traits::create (i, f, this));

      this->labels_.push_back (r);
      continue;
    }

    // place
    //
    if (n.name () == "place" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< place_type > r (
        place_traits::create (i, f, this));

      this->place_.push_back (r);
      continue;
    }

    // transition
    //
    if (n.name () == "transition" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< transition_type > r (
        transition_traits::create (i, f, this));

      this->transition_.push_back (r);
      continue;
    }

    // arc
    //
    if (n.name () == "arc" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< arc_type > r (
        arc_traits::create (i, f, this));

      this->arc_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< id_type > r (
        id_traits::create (i, f, this));

      this->id_.set (r);
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      this->type_.set (r);
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

net_t* net_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class net_t (*this, f, c);
}

net_t::
~net_t ()
{
}

// labels_t
//

labels_t::
labels_t (const text_type& text,
          const border_type& border,
          const height_type& height,
          const width_type& width,
          const x_type& x,
          const y_type& y)
: ::xml_schema::type (),
  text_ (text, ::xml_schema::flags (), this),
  border_ (border, ::xml_schema::flags (), this),
  height_ (height, ::xml_schema::flags (), this),
  width_ (width, ::xml_schema::flags (), this),
  x_ (x, ::xml_schema::flags (), this),
  y_ (y, ::xml_schema::flags (), this)
{
}

labels_t::
labels_t (const labels_t& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  text_ (x.text_, f, this),
  border_ (x.border_, f, this),
  height_ (x.height_, f, this),
  width_ (x.width_, f, this),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this)
{
}

labels_t::
labels_t (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  text_ (f, this),
  border_ (f, this),
  height_ (f, this),
  width_ (f, this),
  x_ (f, this),
  y_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void labels_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // text
    //
    if (n.name () == "text" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< text_type > r (
        text_traits::create (i, f, this));

      if (!text_.present ())
      {
        this->text_.set (r);
        continue;
      }
    }

    break;
  }

  if (!text_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "text",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "border" && n.namespace_ ().empty ())
    {
      this->border_.set (border_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      this->height_.set (height_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }
  }

  if (!border_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "border",
      "");
  }

  if (!height_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "height",
      "");
  }

  if (!width_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "width",
      "");
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }
}

labels_t* labels_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class labels_t (*this, f, c);
}

labels_t::
~labels_t ()
{
}

// place_t
//

place_t::
place_t (const graphics_type& graphics,
         const name_type& name,
         const initialMarking_type& initialMarking,
         const capacity_type& capacity,
         const id_type& id)
: ::xml_schema::type (),
  graphics_ (graphics, ::xml_schema::flags (), this),
  name_ (name, ::xml_schema::flags (), this),
  initialMarking_ (initialMarking, ::xml_schema::flags (), this),
  capacity_ (capacity, ::xml_schema::flags (), this),
  toolspecific_ (::xml_schema::flags (), this),
  id_ (id, ::xml_schema::flags (), this)
{
}

place_t::
place_t (::std::auto_ptr< graphics_type >& graphics,
         ::std::auto_ptr< name_type >& name,
         ::std::auto_ptr< initialMarking_type >& initialMarking,
         ::std::auto_ptr< capacity_type >& capacity,
         const id_type& id)
: ::xml_schema::type (),
  graphics_ (graphics, ::xml_schema::flags (), this),
  name_ (name, ::xml_schema::flags (), this),
  initialMarking_ (initialMarking, ::xml_schema::flags (), this),
  capacity_ (capacity, ::xml_schema::flags (), this),
  toolspecific_ (::xml_schema::flags (), this),
  id_ (id, ::xml_schema::flags (), this)
{
}

place_t::
place_t (const place_t& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  graphics_ (x.graphics_, f, this),
  name_ (x.name_, f, this),
  initialMarking_ (x.initialMarking_, f, this),
  capacity_ (x.capacity_, f, this),
  toolspecific_ (x.toolspecific_, f, this),
  id_ (x.id_, f, this)
{
}

place_t::
place_t (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  graphics_ (f, this),
  name_ (f, this),
  initialMarking_ (f, this),
  capacity_ (f, this),
  toolspecific_ (f, this),
  id_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void place_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // graphics
    //
    if (n.name () == "graphics" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< graphics_type > r (
        graphics_traits::create (i, f, this));

      if (!graphics_.present ())
      {
        this->graphics_.set (r);
        continue;
      }
    }

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!name_.present ())
      {
        this->name_.set (r);
        continue;
      }
    }

    // initialMarking
    //
    if (n.name () == "initialMarking" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< initialMarking_type > r (
        initialMarking_traits::create (i, f, this));

      if (!initialMarking_.present ())
      {
        this->initialMarking_.set (r);
        continue;
      }
    }

    // capacity
    //
    if (n.name () == "capacity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< capacity_type > r (
        capacity_traits::create (i, f, this));

      if (!capacity_.present ())
      {
        this->capacity_.set (r);
        continue;
      }
    }

    // toolspecific
    //
    if (n.name () == "toolspecific" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< toolspecific_type > r (
        toolspecific_traits::create (i, f, this));

      this->toolspecific_.push_back (r);
      continue;
    }

    break;
  }

  if (!graphics_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "graphics",
      "");
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "");
  }

  if (!initialMarking_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "initialMarking",
      "");
  }

  if (!capacity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "capacity",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< id_type > r (
        id_traits::create (i, f, this));

      this->id_.set (r);
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

place_t* place_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class place_t (*this, f, c);
}

place_t::
~place_t ()
{
}

// initialMarking_t
//

initialMarking_t::
initialMarking_t (const value_type& value,
                  const graphics_type& graphics)
: ::xml_schema::type (),
  value_ (value, ::xml_schema::flags (), this),
  graphics_ (graphics, ::xml_schema::flags (), this)
{
}

initialMarking_t::
initialMarking_t (const value_type& value,
                  ::std::auto_ptr< graphics_type >& graphics)
: ::xml_schema::type (),
  value_ (value, ::xml_schema::flags (), this),
  graphics_ (graphics, ::xml_schema::flags (), this)
{
}

initialMarking_t::
initialMarking_t (const initialMarking_t& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  value_ (x.value_, f, this),
  graphics_ (x.graphics_, f, this)
{
}

initialMarking_t::
initialMarking_t (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  value_ (f, this),
  graphics_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void initialMarking_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // value
    //
    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      if (!value_.present ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    // graphics
    //
    if (n.name () == "graphics" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< graphics_type > r (
        graphics_traits::create (i, f, this));

      if (!graphics_.present ())
      {
        this->graphics_.set (r);
        continue;
      }
    }

    break;
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "value",
      "");
  }

  if (!graphics_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "graphics",
      "");
  }
}

initialMarking_t* initialMarking_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class initialMarking_t (*this, f, c);
}

initialMarking_t::
~initialMarking_t ()
{
}

// capacity_t
//

capacity_t::
capacity_t (const value_type& value)
: ::xml_schema::type (),
  value_ (value, ::xml_schema::flags (), this)
{
}

capacity_t::
capacity_t (const capacity_t& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  value_ (x.value_, f, this)
{
}

capacity_t::
capacity_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void capacity_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // value
    //
    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      if (!value_.present ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "value",
      "");
  }
}

capacity_t* capacity_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class capacity_t (*this, f, c);
}

capacity_t::
~capacity_t ()
{
}

// trajectory_t
//

trajectory_t::
trajectory_t (const robot_type& robot,
              const file_type& file)
: ::xml_schema::type (),
  robot_ (robot, ::xml_schema::flags (), this),
  file_ (file, ::xml_schema::flags (), this)
{
}

trajectory_t::
trajectory_t (const trajectory_t& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  robot_ (x.robot_, f, this),
  file_ (x.file_, f, this)
{
}

trajectory_t::
trajectory_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  robot_ (f, this),
  file_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void trajectory_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // robot
    //
    if (n.name () == "robot" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< robot_type > r (
        robot_traits::create (i, f, this));

      if (!robot_.present ())
      {
        this->robot_.set (r);
        continue;
      }
    }

    // file
    //
    if (n.name () == "file" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< file_type > r (
        file_traits::create (i, f, this));

      if (!file_.present ())
      {
        this->file_.set (r);
        continue;
      }
    }

    break;
  }

  if (!robot_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "robot",
      "");
  }

  if (!file_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "file",
      "");
  }
}

trajectory_t* trajectory_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class trajectory_t (*this, f, c);
}

trajectory_t::
~trajectory_t ()
{
}

// toolspecific_t
//

toolspecific_t::
toolspecific_t (const tool_type& tool,
                const version_type& version)
: ::xml_schema::type (),
  task_ (::xml_schema::flags (), this),
  tool_ (tool, ::xml_schema::flags (), this),
  version_ (version, ::xml_schema::flags (), this)
{
}

toolspecific_t::
toolspecific_t (const toolspecific_t& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  task_ (x.task_, f, this),
  tool_ (x.tool_, f, this),
  version_ (x.version_, f, this)
{
}

toolspecific_t::
toolspecific_t (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  task_ (f, this),
  tool_ (f, this),
  version_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void toolspecific_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // task
    //
    if (n.name () == "task" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< task_type > r (
        task_traits::create (i, f, this));

      this->task_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "tool" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< tool_type > r (
        tool_traits::create (i, f, this));

      this->tool_.set (r);
      continue;
    }

    if (n.name () == "version" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< version_type > r (
        version_traits::create (i, f, this));

      this->version_.set (r);
      continue;
    }
  }

  if (!tool_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "tool",
      "");
  }

  if (!version_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "version",
      "");
  }
}

toolspecific_t* toolspecific_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class toolspecific_t (*this, f, c);
}

toolspecific_t::
~toolspecific_t ()
{
}

// transition_t
//

transition_t::
transition_t (const graphics_type& graphics,
              const name_type& name,
              const orientation_type& orientation,
              const rate_type& rate,
              const timed_type& timed,
              const infiniteServer_type& infiniteServer,
              const priority_type& priority,
              const id_type& id)
: ::xml_schema::type (),
  graphics_ (graphics, ::xml_schema::flags (), this),
  name_ (name, ::xml_schema::flags (), this),
  orientation_ (orientation, ::xml_schema::flags (), this),
  rate_ (rate, ::xml_schema::flags (), this),
  timed_ (timed, ::xml_schema::flags (), this),
  infiniteServer_ (infiniteServer, ::xml_schema::flags (), this),
  priority_ (priority, ::xml_schema::flags (), this),
  toolspecific_ (::xml_schema::flags (), this),
  id_ (id, ::xml_schema::flags (), this)
{
}

transition_t::
transition_t (::std::auto_ptr< graphics_type >& graphics,
              ::std::auto_ptr< name_type >& name,
              ::std::auto_ptr< orientation_type >& orientation,
              ::std::auto_ptr< rate_type >& rate,
              ::std::auto_ptr< timed_type >& timed,
              ::std::auto_ptr< infiniteServer_type >& infiniteServer,
              ::std::auto_ptr< priority_type >& priority,
              const id_type& id)
: ::xml_schema::type (),
  graphics_ (graphics, ::xml_schema::flags (), this),
  name_ (name, ::xml_schema::flags (), this),
  orientation_ (orientation, ::xml_schema::flags (), this),
  rate_ (rate, ::xml_schema::flags (), this),
  timed_ (timed, ::xml_schema::flags (), this),
  infiniteServer_ (infiniteServer, ::xml_schema::flags (), this),
  priority_ (priority, ::xml_schema::flags (), this),
  toolspecific_ (::xml_schema::flags (), this),
  id_ (id, ::xml_schema::flags (), this)
{
}

transition_t::
transition_t (const transition_t& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  graphics_ (x.graphics_, f, this),
  name_ (x.name_, f, this),
  orientation_ (x.orientation_, f, this),
  rate_ (x.rate_, f, this),
  timed_ (x.timed_, f, this),
  infiniteServer_ (x.infiniteServer_, f, this),
  priority_ (x.priority_, f, this),
  toolspecific_ (x.toolspecific_, f, this),
  id_ (x.id_, f, this)
{
}

transition_t::
transition_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  graphics_ (f, this),
  name_ (f, this),
  orientation_ (f, this),
  rate_ (f, this),
  timed_ (f, this),
  infiniteServer_ (f, this),
  priority_ (f, this),
  toolspecific_ (f, this),
  id_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void transition_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // graphics
    //
    if (n.name () == "graphics" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< graphics_type > r (
        graphics_traits::create (i, f, this));

      if (!graphics_.present ())
      {
        this->graphics_.set (r);
        continue;
      }
    }

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!name_.present ())
      {
        this->name_.set (r);
        continue;
      }
    }

    // orientation
    //
    if (n.name () == "orientation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< orientation_type > r (
        orientation_traits::create (i, f, this));

      if (!orientation_.present ())
      {
        this->orientation_.set (r);
        continue;
      }
    }

    // rate
    //
    if (n.name () == "rate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rate_type > r (
        rate_traits::create (i, f, this));

      if (!rate_.present ())
      {
        this->rate_.set (r);
        continue;
      }
    }

    // timed
    //
    if (n.name () == "timed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< timed_type > r (
        timed_traits::create (i, f, this));

      if (!timed_.present ())
      {
        this->timed_.set (r);
        continue;
      }
    }

    // infiniteServer
    //
    if (n.name () == "infiniteServer" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< infiniteServer_type > r (
        infiniteServer_traits::create (i, f, this));

      if (!infiniteServer_.present ())
      {
        this->infiniteServer_.set (r);
        continue;
      }
    }

    // priority
    //
    if (n.name () == "priority" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< priority_type > r (
        priority_traits::create (i, f, this));

      if (!priority_.present ())
      {
        this->priority_.set (r);
        continue;
      }
    }

    // toolspecific
    //
    if (n.name () == "toolspecific" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< toolspecific_type > r (
        toolspecific_traits::create (i, f, this));

      if (!this->toolspecific_)
      {
        this->toolspecific_.set (r);
        continue;
      }
    }

    break;
  }

  if (!graphics_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "graphics",
      "");
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "");
  }

  if (!orientation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "orientation",
      "");
  }

  if (!rate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "rate",
      "");
  }

  if (!timed_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "timed",
      "");
  }

  if (!infiniteServer_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "infiniteServer",
      "");
  }

  if (!priority_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "priority",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< id_type > r (
        id_traits::create (i, f, this));

      this->id_.set (r);
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

transition_t* transition_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class transition_t (*this, f, c);
}

transition_t::
~transition_t ()
{
}

// orientation_t
//

orientation_t::
orientation_t (const value_type& value)
: ::xml_schema::type (),
  value_ (value, ::xml_schema::flags (), this)
{
}

orientation_t::
orientation_t (const orientation_t& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  value_ (x.value_, f, this)
{
}

orientation_t::
orientation_t (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void orientation_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // value
    //
    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      if (!value_.present ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "value",
      "");
  }
}

orientation_t* orientation_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class orientation_t (*this, f, c);
}

orientation_t::
~orientation_t ()
{
}

// rate_t
//

rate_t::
rate_t (const value_type& value)
: ::xml_schema::type (),
  value_ (value, ::xml_schema::flags (), this)
{
}

rate_t::
rate_t (const rate_t& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  value_ (x.value_, f, this)
{
}

rate_t::
rate_t (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void rate_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // value
    //
    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      if (!value_.present ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "value",
      "");
  }
}

rate_t* rate_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class rate_t (*this, f, c);
}

rate_t::
~rate_t ()
{
}

// timed_t
//

timed_t::
timed_t (const value_type& value)
: ::xml_schema::type (),
  value_ (value, ::xml_schema::flags (), this)
{
}

timed_t::
timed_t (const timed_t& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  value_ (x.value_, f, this)
{
}

timed_t::
timed_t (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void timed_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // value
    //
    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      if (!value_.present ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "value",
      "");
  }
}

timed_t* timed_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class timed_t (*this, f, c);
}

timed_t::
~timed_t ()
{
}

// infiniteServer_t
//

infiniteServer_t::
infiniteServer_t (const value_type& value)
: ::xml_schema::type (),
  value_ (value, ::xml_schema::flags (), this)
{
}

infiniteServer_t::
infiniteServer_t (const infiniteServer_t& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  value_ (x.value_, f, this)
{
}

infiniteServer_t::
infiniteServer_t (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void infiniteServer_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // value
    //
    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      if (!value_.present ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "value",
      "");
  }
}

infiniteServer_t* infiniteServer_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class infiniteServer_t (*this, f, c);
}

infiniteServer_t::
~infiniteServer_t ()
{
}

// priority_t
//

priority_t::
priority_t (const value_type& value)
: ::xml_schema::type (),
  value_ (value, ::xml_schema::flags (), this)
{
}

priority_t::
priority_t (const priority_t& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  value_ (x.value_, f, this)
{
}

priority_t::
priority_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void priority_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // value
    //
    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      if (!value_.present ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "value",
      "");
  }
}

priority_t* priority_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class priority_t (*this, f, c);
}

priority_t::
~priority_t ()
{
}

// arc_t
//

arc_t::
arc_t (const graphics_type& graphics,
       const inscription_type& inscription,
       const tagged_type& tagged,
       const type_type& type,
       const id_type& id,
       const source_type& source,
       const target_type& target)
: ::xml_schema::type (),
  graphics_ (graphics, ::xml_schema::flags (), this),
  inscription_ (inscription, ::xml_schema::flags (), this),
  tagged_ (tagged, ::xml_schema::flags (), this),
  arcpath_ (::xml_schema::flags (), this),
  type_ (type, ::xml_schema::flags (), this),
  id_ (id, ::xml_schema::flags (), this),
  source_ (source, ::xml_schema::flags (), this),
  target_ (target, ::xml_schema::flags (), this)
{
}

arc_t::
arc_t (::std::auto_ptr< graphics_type >& graphics,
       ::std::auto_ptr< inscription_type >& inscription,
       ::std::auto_ptr< tagged_type >& tagged,
       ::std::auto_ptr< type_type >& type,
       const id_type& id,
       const source_type& source,
       const target_type& target)
: ::xml_schema::type (),
  graphics_ (graphics, ::xml_schema::flags (), this),
  inscription_ (inscription, ::xml_schema::flags (), this),
  tagged_ (tagged, ::xml_schema::flags (), this),
  arcpath_ (::xml_schema::flags (), this),
  type_ (type, ::xml_schema::flags (), this),
  id_ (id, ::xml_schema::flags (), this),
  source_ (source, ::xml_schema::flags (), this),
  target_ (target, ::xml_schema::flags (), this)
{
}

arc_t::
arc_t (const arc_t& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  graphics_ (x.graphics_, f, this),
  inscription_ (x.inscription_, f, this),
  tagged_ (x.tagged_, f, this),
  arcpath_ (x.arcpath_, f, this),
  type_ (x.type_, f, this),
  id_ (x.id_, f, this),
  source_ (x.source_, f, this),
  target_ (x.target_, f, this)
{
}

arc_t::
arc_t (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  graphics_ (f, this),
  inscription_ (f, this),
  tagged_ (f, this),
  arcpath_ (f, this),
  type_ (f, this),
  id_ (f, this),
  source_ (f, this),
  target_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void arc_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // graphics
    //
    if (n.name () == "graphics" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< graphics_type > r (
        graphics_traits::create (i, f, this));

      if (!graphics_.present ())
      {
        this->graphics_.set (r);
        continue;
      }
    }

    // inscription
    //
    if (n.name () == "inscription" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< inscription_type > r (
        inscription_traits::create (i, f, this));

      if (!inscription_.present ())
      {
        this->inscription_.set (r);
        continue;
      }
    }

    // tagged
    //
    if (n.name () == "tagged" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< tagged_type > r (
        tagged_traits::create (i, f, this));

      if (!tagged_.present ())
      {
        this->tagged_.set (r);
        continue;
      }
    }

    // arcpath
    //
    if (n.name () == "arcpath" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< arcpath_type > r (
        arcpath_traits::create (i, f, this));

      this->arcpath_.push_back (r);
      continue;
    }

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!type_.present ())
      {
        this->type_.set (r);
        continue;
      }
    }

    break;
  }

  if (!graphics_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "graphics",
      "");
  }

  if (!inscription_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "inscription",
      "");
  }

  if (!tagged_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tagged",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< id_type > r (
        id_traits::create (i, f, this));

      this->id_.set (r);
      continue;
    }

    if (n.name () == "source" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< source_type > r (
        source_traits::create (i, f, this));

      this->source_.set (r);
      continue;
    }

    if (n.name () == "target" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< target_type > r (
        target_traits::create (i, f, this));

      this->target_.set (r);
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!source_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "source",
      "");
  }

  if (!target_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "target",
      "");
  }
}

arc_t* arc_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class arc_t (*this, f, c);
}

arc_t::
~arc_t ()
{
}

// inscription_t
//

inscription_t::
inscription_t (const value_type& value,
               const graphics_type& graphics)
: ::xml_schema::type (),
  value_ (value, ::xml_schema::flags (), this),
  graphics_ (graphics, ::xml_schema::flags (), this)
{
}

inscription_t::
inscription_t (const value_type& value,
               ::std::auto_ptr< graphics_type >& graphics)
: ::xml_schema::type (),
  value_ (value, ::xml_schema::flags (), this),
  graphics_ (graphics, ::xml_schema::flags (), this)
{
}

inscription_t::
inscription_t (const inscription_t& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  value_ (x.value_, f, this),
  graphics_ (x.graphics_, f, this)
{
}

inscription_t::
inscription_t (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  value_ (f, this),
  graphics_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void inscription_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // value
    //
    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      if (!value_.present ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    // graphics
    //
    if (n.name () == "graphics" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< graphics_type > r (
        graphics_traits::create (i, f, this));

      if (!graphics_.present ())
      {
        this->graphics_.set (r);
        continue;
      }
    }

    break;
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "value",
      "");
  }

  if (!graphics_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "graphics",
      "");
  }
}

inscription_t* inscription_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class inscription_t (*this, f, c);
}

inscription_t::
~inscription_t ()
{
}

// tagged_t
//

tagged_t::
tagged_t (const value_type& value)
: ::xml_schema::type (),
  value_ (value, ::xml_schema::flags (), this)
{
}

tagged_t::
tagged_t (const tagged_t& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  value_ (x.value_, f, this)
{
}

tagged_t::
tagged_t (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void tagged_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // value
    //
    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      if (!value_.present ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "value",
      "");
  }
}

tagged_t* tagged_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class tagged_t (*this, f, c);
}

tagged_t::
~tagged_t ()
{
}

// arcpath_t
//

arcpath_t::
arcpath_t (const curvePoint_type& curvePoint,
           const id_type& id,
           const x_type& x,
           const y_type& y)
: ::xml_schema::type (),
  curvePoint_ (curvePoint, ::xml_schema::flags (), this),
  id_ (id, ::xml_schema::flags (), this),
  x_ (x, ::xml_schema::flags (), this),
  y_ (y, ::xml_schema::flags (), this)
{
}

arcpath_t::
arcpath_t (const arcpath_t& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  curvePoint_ (x.curvePoint_, f, this),
  id_ (x.id_, f, this),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this)
{
}

arcpath_t::
arcpath_t (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  curvePoint_ (f, this),
  id_ (f, this),
  x_ (f, this),
  y_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void arcpath_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "curvePoint" && n.namespace_ ().empty ())
    {
      this->curvePoint_.set (curvePoint_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }
  }

  if (!curvePoint_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "curvePoint",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }
}

arcpath_t* arcpath_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class arcpath_t (*this, f, c);
}

arcpath_t::
~arcpath_t ()
{
}

// type_t
//

type_t::
type_t (const value_type& value)
: ::xml_schema::type (),
  value_ (value, ::xml_schema::flags (), this)
{
}

type_t::
type_t (const type_t& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  value_ (x.value_, f, this)
{
}

type_t::
type_t (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void type_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< value_type > r (
        value_traits::create (i, f, this));

      this->value_.set (r);
      continue;
    }
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "value",
      "");
  }
}

type_t* type_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class type_t (*this, f, c);
}

type_t::
~type_t ()
{
}

// graphics_t
//

graphics_t::
graphics_t ()
: ::xml_schema::type (),
  offset_ (::xml_schema::flags (), this),
  position_ (::xml_schema::flags (), this)
{
}

graphics_t::
graphics_t (const graphics_t& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  offset_ (x.offset_, f, this),
  position_ (x.position_, f, this)
{
}

graphics_t::
graphics_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  offset_ (f, this),
  position_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void graphics_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // offset
    //
    if (n.name () == "offset" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< offset_type > r (
        offset_traits::create (i, f, this));

      if (!this->offset_)
      {
        this->offset_.set (r);
        continue;
      }
    }

    // position
    //
    if (n.name () == "position" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< position_type > r (
        position_traits::create (i, f, this));

      if (!this->position_)
      {
        this->position_.set (r);
        continue;
      }
    }

    break;
  }
}

graphics_t* graphics_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class graphics_t (*this, f, c);
}

graphics_t::
~graphics_t ()
{
}

// offset_t
//

offset_t::
offset_t (const x_type& x,
          const y_type& y)
: ::xml_schema::type (),
  x_ (x, ::xml_schema::flags (), this),
  y_ (y, ::xml_schema::flags (), this)
{
}

offset_t::
offset_t (const offset_t& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this)
{
}

offset_t::
offset_t (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (f, this),
  y_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void offset_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }
}

offset_t* offset_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class offset_t (*this, f, c);
}

offset_t::
~offset_t ()
{
}

// position_t
//

position_t::
position_t (const x_type& x,
            const y_type& y)
: ::xml_schema::type (),
  x_ (x, ::xml_schema::flags (), this),
  y_ (y, ::xml_schema::flags (), this)
{
}

position_t::
position_t (const position_t& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this)
{
}

position_t::
position_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (f, this),
  y_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void position_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }
}

position_t* position_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class position_t (*this, f, c);
}

position_t::
~position_t ()
{
}

// name_t
//

name_t::
name_t (const value_type& value,
        const graphics_type& graphics)
: ::xml_schema::type (),
  value_ (value, ::xml_schema::flags (), this),
  graphics_ (graphics, ::xml_schema::flags (), this)
{
}

name_t::
name_t (const value_type& value,
        ::std::auto_ptr< graphics_type >& graphics)
: ::xml_schema::type (),
  value_ (value, ::xml_schema::flags (), this),
  graphics_ (graphics, ::xml_schema::flags (), this)
{
}

name_t::
name_t (const name_t& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  value_ (x.value_, f, this),
  graphics_ (x.graphics_, f, this)
{
}

name_t::
name_t (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  value_ (f, this),
  graphics_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void name_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // value
    //
    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< value_type > r (
        value_traits::create (i, f, this));

      if (!value_.present ())
      {
        this->value_.set (r);
        continue;
      }
    }

    // graphics
    //
    if (n.name () == "graphics" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< graphics_type > r (
        graphics_traits::create (i, f, this));

      if (!graphics_.present ())
      {
        this->graphics_.set (r);
        continue;
      }
    }

    break;
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "value",
      "");
  }

  if (!graphics_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "graphics",
      "");
  }
}

name_t* name_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class name_t (*this, f, c);
}

name_t::
~name_t ()
{
}

// name1_t
//

name1_t::
name1_t (const value_type& value)
: ::xml_schema::type (),
  value_ (value, ::xml_schema::flags (), this)
{
}

name1_t::
name1_t (const name1_t& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  value_ (x.value_, f, this)
{
}

name1_t::
name1_t (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void name1_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // value
    //
    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< value_type > r (
        value_traits::create (i, f, this));

      if (!value_.present ())
      {
        this->value_.set (r);
        continue;
      }
    }

    break;
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "value",
      "");
  }
}

name1_t* name1_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class name1_t (*this, f, c);
}

name1_t::
~name1_t ()
{
}

// task_t
//

task_t::
task_t ()
: ::xml_schema::type (),
  exec_ (::xml_schema::flags (), this),
  trajectory_ (::xml_schema::flags (), this)
{
}

task_t::
task_t (const task_t& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  exec_ (x.exec_, f, this),
  trajectory_ (x.trajectory_, f, this)
{
}

task_t::
task_t (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  exec_ (f, this),
  trajectory_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void task_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // exec
    //
    if (n.name () == "exec" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< exec_type > r (
        exec_traits::create (i, f, this));

      if (!this->exec_)
      {
        this->exec_.set (r);
        continue;
      }
    }

    // trajectory
    //
    if (n.name () == "trajectory" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< trajectory_type > r (
        trajectory_traits::create (i, f, this));

      if (!this->trajectory_)
      {
        this->trajectory_.set (r);
        continue;
      }
    }

    break;
  }
}

task_t* task_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class task_t (*this, f, c);
}

task_t::
~task_t ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::pnml_t >
pnml (const ::std::string& u,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::pnml_t > r (
    ::pnml (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::pnml_t >
pnml (const ::std::string& u,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::pnml_t > r (
    ::pnml (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::pnml_t >
pnml (const ::std::string& u,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::pnml_t > r (
    ::pnml (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::pnml_t >
pnml (::std::istream& is,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::pnml (isrc, f, p);
}

::std::auto_ptr< ::pnml_t >
pnml (::std::istream& is,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::pnml (isrc, h, f, p);
}

::std::auto_ptr< ::pnml_t >
pnml (::std::istream& is,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::pnml (isrc, h, f, p);
}

::std::auto_ptr< ::pnml_t >
pnml (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::pnml (isrc, f, p);
}

::std::auto_ptr< ::pnml_t >
pnml (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::pnml (isrc, h, f, p);
}

::std::auto_ptr< ::pnml_t >
pnml (::std::istream& is,
      const ::std::string& sid,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::pnml (isrc, h, f, p);
}

::std::auto_ptr< ::pnml_t >
pnml (::xercesc::InputSource& i,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::pnml_t > r (
    ::pnml (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::pnml_t >
pnml (::xercesc::InputSource& i,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::pnml_t > r (
    ::pnml (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::pnml_t >
pnml (::xercesc::InputSource& i,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::pnml_t > r (
    ::pnml (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::pnml_t >
pnml (const ::xercesc::DOMDocument& d,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::pnml_t > r (
      ::pnml (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "pnml" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::pnml_t > r (
      ::xsd::cxx::tree::traits< ::pnml_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "pnml",
    "");
}

::std::auto_ptr< ::pnml_t >
pnml (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
      ::xml_schema::flags f,
      const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "pnml" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::pnml_t > r (
      ::xsd::cxx::tree::traits< ::pnml_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "pnml",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

